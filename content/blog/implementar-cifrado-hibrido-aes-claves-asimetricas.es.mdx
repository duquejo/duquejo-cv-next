---
slug: implementar-cifrado-hibrido-aes-claves-asimetricas
slugEn: implementar-cifrado-hibrido-aes-claves-asimetricas
slugEs: implementar-cifrado-hibrido-aes-claves-asimetricas
title: Cómo implementar cifrado híbrido con AES y claves asimétricas
excerpt: Una guía práctica para implementar cifrado híbrido utilizando AES y claves asimétricas en aplicaciones seguras.
category: Seguridad
tags: [Seguridad, Backend, Encriptación, Criptografía, AES, RSA, Cifrado Híbrido]
publishDate: 2025-11-15T12:34:00.000Z
readingTime: 15 minutos
---

## Introducción

Hace algunos años, mientras trabajaba en un proyecto que requería un alto nivel de seguridad para la transmisión de datos, me encontré con la necesidad de implementar un sistema de cifrado híbrido. Este enfoque combina la velocidad del cifrado simétrico con la seguridad del cifrado asimétrico, y en esta publicación compartiré cómo lo logré utilizando AES para el cifrado simétrico y claves asimétricas para el intercambio seguro de información.

Dada la necesidad, entonces utilicé Nest.js (_¡Un excelente framework!_) como mi backend, el cual fué mi herramienta predilecta para realizar la prueba de concepto del reto que tenía en mente.

### Conceptos clave

Antes de sumergirnos en la implementación, repasemos brevemente los conceptos clave:

- **Cifrado Simétrico:** Utiliza la misma clave para cifrar y descifrar datos. Es rápido y eficiente, ideal para grandes volúmenes de datos, pero recae en la seguridad de la clave compartida.
- **AES (Advanced Encryption Standard):** es un algoritmo de cifrado **simétrico** ampliamente utilizado debido a su velocidad y seguridad.

- **Cifrado Asimétrico:** Utiliza un par de claves _(pública y privada)_. La clave pública cifra los datos, mientras que la clave privada los descifra. Es más seguro para el intercambio de claves, pero más lento.
- **RSA:** es un algoritmo de cifrado **asimétrico** comúnmente utilizado para el intercambio seguro de claves.

Ahora conociendo los conceptos básicos, es importante entender que en la práctica combinar ambos métodos, es ideal para lograr el objetivo de seguridad y eficiencia. Aquí es donde entra en juego el cifrado híbrido.

### Implementación del Cifrado Híbrido

#### Requerimentos previos

1. Se genera desde el servidor un par de claves RSA (pública y privada).
2. El servidor envía la clave pública RSA al cliente.

#### Flujo de Encriptación (Cifrado AES-256 en modo CTR)

1. El cliente genera un vector de iniciación (IV) aleatorio. Esto garantiza que cada mensaje cifrado sea único.
2. El cliente cifra los datos utilizando la clave AES.
3. El cliente cifra la clave AES utilizando la clave pública RSA del servidor.
4. El cliente envía tanto los datos cifrados como la clave AES cifrada al servidor.

```typescript
import { promisify } from 'util';
import { scrypt, randomBytes, createCipheriv } from 'crypto';

public async encryptAES(payload: string): Promise<string> {
  const iv = randomBytes(16);

  const key = (await promisify(scrypt)(this.passphrase, 'salt', 32)) as Buffer;
  const cipher = createCipheriv('aes-256-ctr', key, iv);
  const encryptedText = Buffer.concat([
      cipher.update(payload),
      cipher.final(),
  ]);

  const encryptedTextStr = encryptedText.toString('base64');
  return `${iv.toString('base64')}:${encryptedTextStr}`;
}
```

```typescript
public async decryptAES(text: string): Promise<string> {
  const textParts = text.split(':');
  const iv = Buffer.from(textParts.shift(), 'base64');
  const encryptedText = Buffer.from(textParts.join(':'), 'base64');


  const key = (await promisify(scrypt)(this.passphrase, 'salt', 32)) as Buffer;
  const decipher = createDecipheriv('aes-256-ctr', key, iv);
  const decryptedText = Buffer.concat([
      decipher.update(encryptedText),
      decipher.final(),
  ]);

  return decryptedText.toString();
}
```

```typescript
import * as fs from 'fs';
import * as path from 'path';
import * as forge from 'node-forge';

public async decryptWithPrivateKey(payload: string) {
  try {
    const privateKeyPem = fs.readFileSync(
        path.resolve(process.cwd(), '.', 'keys', 'private.pem'), 'utf-8'
    );
    const privateKeyForge = forge.pki.privateKeyFromPem(privateKeyPem);
    const decodedPayload = forge.util.decode64(payload);
    return privateKeyForge.decrypt(decodedPayload);
  } catch (error) {
    console.error(error);
    return payload;
  }
}
```
